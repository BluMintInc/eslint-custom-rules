name: Link PR to Source Issue

'on':
  pull_request:
    types: [opened]

permissions:
  contents: read
  pull-requests: write
  issues: read

jobs:
  link_issue_on_pr:
    runs-on: ubuntu-latest
    steps:
      - name: Ensure gh and jq are available
        run: |
          if ! command -v gh >/dev/null 2>&1; then
            sudo apt-get update && sudo apt-get install -y gh
          fi
          if ! command -v jq >/dev/null 2>&1; then
            sudo apt-get update && sudo apt-get install -y jq
          fi

      - name: Prepend "Closes <issue-number>" (and second-order) to PR body based on branch name
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          PR_NUMBER: ${{ github.event.pull_request.number }}
          BRANCH: ${{ github.head_ref }}
          REPO: ${{ github.repository }}
        run: |
          set -euo pipefail
          # Extract the issue number from agent branch patterns "develop-implement-rule-<ISSUE_NUMBER>" or "develop-fix-bug-<ISSUE_NUMBER>"
          ISSUE_NUMBER=$(echo "$BRANCH" | sed -nE 's/.*-(implement-rule|fix-bug)-([0-9]+).*/\2/p') || true
          if [ -z "${ISSUE_NUMBER:-}" ]; then
            echo "Branch does not match *-(implement-rule|fix-bug)-<number>; skipping."
            exit 0
          fi

          # Get current PR body from event context
          CURRENT_BODY=$(jq -r '.pull_request.body // ""' "$GITHUB_EVENT_PATH")

          # Prepare list of issues to close (primary + optional second-order)
          ISSUES_TO_CLOSE=()
          ISSUES_TO_CLOSE+=("$ISSUE_NUMBER")

          # Fetch the primary linked issue to inspect labels (requires issues: read)
          PRIMARY_ISSUE_JSON="$(gh api "repos/${REPO}/issues/${ISSUE_NUMBER}")"
          HAS_DIAGNOSIS="$(printf '%s' "$PRIMARY_ISSUE_JSON" | jq -r '[.labels[].name // empty | ascii_downcase] | index("diagnosis") | if . == null then "false" else "true" end')"

          if [ "$HAS_DIAGNOSIS" = "true" ]; then
            # Extract second-order issue numbers referenced in the primary issue body (e.g., "#123")
            # Pattern matches GitHub issue references: # followed by digits, where # is preceded by
            # start-of-line/whitespace/closing-keywords and number is followed by non-digit or end-of-line.
            # Single-digit numbers are only included if preceded by closing keywords to avoid false positives
            # from phrases like "step #1" or "section #1".
            PRIMARY_BODY="$(printf '%s' "$PRIMARY_ISSUE_JSON" | jq -r '.body // ""')"
            if [ -n "$PRIMARY_BODY" ]; then
              # Extract all potential issue references
              mapfile -t CANDIDATES < <(printf '%s\n' "$PRIMARY_BODY" | grep -Eo '(^|[[:space:]]|closes|fixes|resolves)[[:space:]]*#[0-9]+([^0-9]|$)' | sed -E 's/.*#([0-9]+).*/\1/' || true)
              for num in "${CANDIDATES[@]:-}"; do
                # Skip if same as primary
                if [ "$num" = "$ISSUE_NUMBER" ]; then
                  continue
                fi
                # Filter: single-digit numbers only if preceded by closing keyword
                if [ ${#num} -eq 1 ]; then
                  if printf '%s\n' "$PRIMARY_BODY" | grep -qiE "(closes|fixes|resolves)[[:space:]]*#${num}([^0-9]|$)"; then
                    ISSUES_TO_CLOSE+=("$num")
                  fi
                else
                  ISSUES_TO_CLOSE+=("$num")
                fi
              done
            fi

            # Also extract second-order issue numbers referenced in comments on the primary issue
            PRIMARY_COMMENTS_JSON="$(gh api "repos/${REPO}/issues/${ISSUE_NUMBER}/comments?per_page=100" || echo '[]')"
            if [ -n "$PRIMARY_COMMENTS_JSON" ] && [ "$PRIMARY_COMMENTS_JSON" != "[]" ]; then
              COMMENT_BODIES="$(printf '%s' "$PRIMARY_COMMENTS_JSON" | jq -r '.[].body // empty')"
              if [ -n "$COMMENT_BODIES" ]; then
                mapfile -t CANDIDATES_FROM_COMMENTS < <(printf '%s\n' "$COMMENT_BODIES" | grep -Eo '(^|[[:space:]]|closes|fixes|resolves)[[:space:]]*#[0-9]+([^0-9]|$)' | sed -E 's/.*#([0-9]+).*/\1/' || true)
                for num in "${CANDIDATES_FROM_COMMENTS[@]:-}"; do
                  if [ "$num" = "$ISSUE_NUMBER" ]; then
                    continue
                  fi
                  # Filter: single-digit numbers only if preceded by closing keyword
                  if [ ${#num} -eq 1 ]; then
                    if printf '%s\n' "$COMMENT_BODIES" | grep -qiE "(closes|fixes|resolves)[[:space:]]*#${num}([^0-9]|$)"; then
                      ISSUES_TO_CLOSE+=("$num")
                    fi
                  else
                    ISSUES_TO_CLOSE+=("$num")
                  fi
                done
              fi
            fi
          fi

          # Deduplicate issue numbers
          mapfile -t ISSUES_TO_CLOSE < <(printf '%s\n' "${ISSUES_TO_CLOSE[@]}" | sort -u)

          # Build "Closes ..." lines for any issues not already declared in PR body
          PREPEND_LINES=""
          for num in "${ISSUES_TO_CLOSE[@]}"; do
            if ! printf '%s' "$CURRENT_BODY" | grep -Ei -q "(^|[[:space:]])(closes|fixes|resolves)[[:space:]]*#${num}([[:space:]]|$)"; then
              PREPEND_LINES="${PREPEND_LINES}Closes #${num}\n"
            fi
          done

          if [ -z "$PREPEND_LINES" ]; then
            echo "PR body already contains required closing references; skipping."
            exit 0
          fi

          NEW_BODY=$(printf '%b\n\n%s' "$PREPEND_LINES" "$CURRENT_BODY")

          gh api \
            "repos/${REPO}/pulls/${PR_NUMBER}" \
            -X PATCH \
            -f body="$NEW_BODY"
