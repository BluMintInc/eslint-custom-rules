import path from 'path';
import { minimatch } from 'minimatch';
import { TSESTree } from '@typescript-eslint/utils';
import { createRule } from '../utils/createRule';

type NormalizedOptions = {
  requiredPatterns: string[];
  excludedPatterns: string[];
  requiredTags: string[];
  allowSplitHeaders: boolean;
  headerTemplate: string | null;
  ignoreGeneratedFiles: boolean;
  generatedMarkers: string[];
  excludedAtDirectives: string[];
};

type Options = [Partial<NormalizedOptions>];

type MessageIds = 'missingHeader' | 'duplicateHeader' | 'splitHeaderFragment';

type HeaderGroup = {
  comments: TSESTree.Comment[];
  text: string;
};

const DEFAULT_OPTIONS: NormalizedOptions = {
  requiredPatterns: ['**/*.{ts,tsx,js,jsx}'],
  excludedPatterns: ['**/*.d.ts', '**/dist/**', '**/build/**', '**/coverage/**'],
  requiredTags: ['@fileoverview'],
  allowSplitHeaders: true,
  headerTemplate: null,
  ignoreGeneratedFiles: true,
  generatedMarkers: [
    '@generated',
    'auto-generated',
    'autogenerated',
    'do not edit',
    'do not edit manually',
  ],
  excludedAtDirectives: [
    '@ts-nocheck',
    '@ts-check',
    '@ts-ignore',
    '@ts-expect-error',
    '@jsx',
    '@jsxruntime',
    '@jsximportsource',
    '@format',
    '@flow',
    '@jest-environment',
    '@vitest-environment',
  ],
};

/**
 * Maximum number of characters to scan at the beginning of a file to detect generated markers.
 */
const GENERATED_MARKER_SCAN_LENGTH = 500;

const normalizeArrayOption = <T>(values: T[] | undefined, fallback: T[]): T[] =>
  values && values.length > 0 ? values : fallback;

const normalizeArrayOptionAllowEmpty = <T>(values: T[] | undefined, fallback: T[]): T[] =>
  values === undefined ? fallback : values;

const normalizeBooleanOption = (value: boolean | undefined, fallback: boolean): boolean =>
  value ?? fallback;

const normalizeNullableOption = <T>(
  value: T | null | undefined,
  fallback: T | null,
): T | null => (value === undefined ? fallback : value);

const normalizeOptions = (options?: Partial<NormalizedOptions>): NormalizedOptions => ({
  requiredPatterns: normalizeArrayOption(options?.requiredPatterns, DEFAULT_OPTIONS.requiredPatterns),
  excludedPatterns: normalizeArrayOptionAllowEmpty(
    options?.excludedPatterns,
    DEFAULT_OPTIONS.excludedPatterns,
  ),
  requiredTags: normalizeArrayOption(options?.requiredTags, DEFAULT_OPTIONS.requiredTags),
  allowSplitHeaders: normalizeBooleanOption(
    options?.allowSplitHeaders,
    DEFAULT_OPTIONS.allowSplitHeaders,
  ),
  headerTemplate: normalizeNullableOption(options?.headerTemplate, DEFAULT_OPTIONS.headerTemplate),
  ignoreGeneratedFiles: normalizeBooleanOption(
    options?.ignoreGeneratedFiles,
    DEFAULT_OPTIONS.ignoreGeneratedFiles,
  ),
  generatedMarkers: normalizeArrayOptionAllowEmpty(
    options?.generatedMarkers,
    DEFAULT_OPTIONS.generatedMarkers,
  ),
  excludedAtDirectives: normalizeArrayOptionAllowEmpty(
    options?.excludedAtDirectives?.map((directive) => directive.toLowerCase()),
    DEFAULT_OPTIONS.excludedAtDirectives,
  ),
});

const normalizeCommentValue = (comment: TSESTree.Comment): string =>
  comment.value
    .split('\n')
    .map((line) => line.replace(/^\s*\*\s?/, '').trim())
    .join('\n')
    .trim();

const hasRequiredTags = (text: string, requiredTagsLower: string[]): boolean => {
  const lowerText = text.toLowerCase();

  return requiredTagsLower.some((tag) => lowerText.includes(tag));
};

const hasHeaderMarker = (text: string, excludedAtDirectives: Set<string>): boolean =>
  text.split('\n').some((line) => {
    const trimmed = line.trimStart();

    if (!trimmed.startsWith('@')) {
      return false;
    }

    const marker = trimmed.split(/\s+/u)[0].toLowerCase();

    return !excludedAtDirectives.has(marker);
  });

const isHeaderCandidate = (
  text: string,
  requiredTagsLower: string[],
  excludedAtDirectives: Set<string>,
): boolean => hasRequiredTags(text, requiredTagsLower) || hasHeaderMarker(text, excludedAtDirectives);

/**
 * Merges adjacent header candidate comments into a single group if they are not already complete headers.
 * This handles "split headers" where metadata is spread across multiple comment blocks.
 */
const mergeAdjacentHeaderCandidates = (
  comments: TSESTree.Comment[],
  startIndex: number,
  initialComment: TSESTree.Comment,
  initialText: string,
  requiredTagsLower: string[],
  excludedAtDirectives: Set<string>,
): {
  mergedComments: TSESTree.Comment[];
  mergedText: string;
  lastIndex: number;
} => {
  const mergedComments = [initialComment];
  let mergedText = initialText;
  let groupedHasAllTags = requiredTagsLower.every((tag) =>
    mergedText.toLowerCase().includes(tag),
  );

  let nextIndex = startIndex + 1;
  while (nextIndex < comments.length) {
    const nextComment = comments[nextIndex];
    const lastComment = mergedComments[mergedComments.length - 1];

    // Check if the next comment is on the line immediately following the last one.
    const isAdjacent = nextComment.loc.start.line <= lastComment.loc.end.line + 1;

    if (!isAdjacent) {
      break;
    }

    const nextNormalized = normalizeCommentValue(nextComment);

    if (!isHeaderCandidate(nextNormalized, requiredTagsLower, excludedAtDirectives)) {
      break;
    }

    const nextHasAllTags = requiredTagsLower.every((tag) =>
      nextNormalized.toLowerCase().includes(tag),
    );

    // Stop merging if both the current group and the next candidate are already complete headers.
    if (groupedHasAllTags && nextHasAllTags) {
      break;
    }

    mergedText = `${mergedText}\n${nextNormalized}`.trim();
    groupedHasAllTags = requiredTagsLower.every((tag) =>
      mergedText.toLowerCase().includes(tag),
    );

    mergedComments.push(nextComment);
    nextIndex += 1;
  }

  return {
    mergedComments,
    mergedText,
    lastIndex: nextIndex - 1,
  };
};

const collectHeaderGroups = (
  comments: TSESTree.Comment[],
  options: NormalizedOptions,
  excludedAtDirectives: Set<string>,
): HeaderGroup[] => {
  const requiredTagsLower = options.requiredTags.map((tag) => tag.toLowerCase());
  const groups: HeaderGroup[] = [];

  for (let index = 0; index < comments.length; index += 1) {
    const comment = comments[index];
    const normalized = normalizeCommentValue(comment);

    if (!isHeaderCandidate(normalized, requiredTagsLower, excludedAtDirectives)) {
      continue;
    }

    let groupedComments = [comment];
    let groupedText = normalized;

    if (options.allowSplitHeaders) {
      const merged = mergeAdjacentHeaderCandidates(
        comments,
        index,
        comment,
        normalized,
        requiredTagsLower,
        excludedAtDirectives,
      );
      groupedComments = merged.mergedComments;
      groupedText = merged.mergedText;
      index = merged.lastIndex;
    }

    groups.push({ comments: groupedComments, text: groupedText });
  }

  return groups;
};

const expandRangeToFullLines = (
  range: TSESTree.Range,
  sourceText: string,
): TSESTree.Range => {
  let [start, end] = range;

  while (start > 0 && sourceText[start - 1] !== '\n') {
    start -= 1;
  }

  while (end < sourceText.length && sourceText[end] !== '\n') {
    end += 1;
  }

  if (end < sourceText.length) {
    end += 1;
  }

  return [start, end];
};

// Preserve author-provided trailing newlines while guaranteeing a blank line after the header.
const buildHeaderInsertionText = (template: string): string => {
  const normalizedWhitespace = template
    .replace(/[ \t]+(\r?\n)/gu, '$1')
    .replace(/[ \t]+$/u, '');
  const trailingNewlines = normalizedWhitespace.match(/\n+$/u)?.[0].length ?? 0;
  const requiredNewlines = trailingNewlines >= 2 ? 0 : 2 - trailingNewlines;

  return `${normalizedWhitespace}${'\n'.repeat(requiredNewlines)}`;
};

export const RULE_NAME = 'enforce-unique-cursor-headers';

export const enforceUniqueCursorHeaders = createRule<Options, MessageIds>({
  name: RULE_NAME,
  meta: {
    type: 'suggestion',
    docs: {
      description:
        'Ensure files have exactly one cursor header containing required tags (e.g., @fileoverview) before any code',
      recommended: 'error',
    },
    fixable: 'code',
    schema: [
      {
        type: 'object',
        properties: {
          requiredPatterns: {
            type: 'array',
            items: { type: 'string' },
          },
          excludedPatterns: {
            type: 'array',
            items: { type: 'string' },
          },
          requiredTags: {
            type: 'array',
            items: { type: 'string' },
          },
          allowSplitHeaders: {
            type: 'boolean',
          },
          headerTemplate: {
            type: ['string', 'null'],
          },
          ignoreGeneratedFiles: {
            type: 'boolean',
          },
          generatedMarkers: {
            type: 'array',
            items: { type: 'string' },
          },
          excludedAtDirectives: {
            type: 'array',
            items: { type: 'string' },
          },
        },
        additionalProperties: false,
      },
    ],
    messages: {
      missingHeader:
        'File "{{fileName}}" is missing a cursor header before any imports or code → Cursor headers keep ownership and metadata discoverable for automation → Add one top-of-file cursor header containing: {{tags}}.',
      duplicateHeader:
        'Multiple cursor headers detected before the first statement (extra header starts on line {{line}}) → Duplicate metadata blocks conflict and make ownership ambiguous → Keep exactly one cursor header at the top and remove the extra block.',
      splitHeaderFragment:
        'Cursor header metadata is split across adjacent comment blocks → Fragmented headers are easy to miss and let required tags drift out of sync → Merge the fragments into a single top-of-file header containing: {{tags}}.',
    },
  },
  defaultOptions: [DEFAULT_OPTIONS],
  create(context, [userOptions]) {
    const options = normalizeOptions(userOptions);
    const fileName = context.getFilename();
    const matchPath = fileName.split(path.sep).join('/');
    const excludedAtDirectives = new Set(
      options.excludedAtDirectives.map((directive) => directive.toLowerCase()),
    );

    if (fileName === '<input>') {
      return {};
    }

    const matchesRequired = options.requiredPatterns.some((pattern) =>
      minimatch(matchPath, pattern, { dot: true }),
    );

    if (!matchesRequired) {
      return {};
    }

    const matchesExcluded = options.excludedPatterns.some((pattern) =>
      minimatch(matchPath, pattern, { dot: true }),
    );

    if (matchesExcluded) {
      return {};
    }

    return {
      Program(node) {
        const sourceCode = context.getSourceCode();
        const sourceText = sourceCode.getText();

        if (options.ignoreGeneratedFiles) {
          const prefix = sourceText.slice(0, GENERATED_MARKER_SCAN_LENGTH).toLowerCase();

          if (
            options.generatedMarkers.some((marker) =>
              prefix.includes(marker.toLowerCase()),
            )
          ) {
            return;
          }
        }

        const allComments = sourceCode.getAllComments();
        const firstToken = sourceCode.getFirstToken(node);
        const firstTokenLine = firstToken?.loc.start.line ?? Infinity;
        const topComments = allComments.filter(
          (comment) => comment.loc.start.line < firstTokenLine,
        );

        const candidateGroups = collectHeaderGroups(topComments, options, excludedAtDirectives);
        const requiredTagsLower = options.requiredTags.map((tag) => tag.toLowerCase());
        const headerGroups = candidateGroups.filter((group) =>
          requiredTagsLower.every((tag) => group.text.toLowerCase().includes(tag)),
        );
        const primaryHeader = headerGroups[0];

        if (!primaryHeader) {
          context.report({
            loc: { line: 1, column: 0 },
            messageId: 'missingHeader',
            data: {
              fileName: path.basename(fileName),
              tags: options.requiredTags.join(', '),
            },
            fix: options.headerTemplate !== null
              ? (fixer) => {
                  const hasShebang = sourceText.startsWith('#!');
                  const shebangNewlineIndex = hasShebang ? sourceText.indexOf('\n') : -1;
                  const insertionIndex =
                    hasShebang && shebangNewlineIndex !== -1
                      ? shebangNewlineIndex + 1
                      : hasShebang
                        ? sourceText.length
                        : 0;
                  const headerText = buildHeaderInsertionText(
                    options.headerTemplate as string,
                  );
                  const textToInsert =
                    hasShebang && shebangNewlineIndex === -1
                      ? `\n${headerText}`
                      : headerText;

                  return fixer.insertTextBeforeRange([insertionIndex, insertionIndex], textToInsert);
                }
              : null,
          });

          return;
        }

        const duplicateGroups = headerGroups.slice(1);

        const splitHeaderGroups = options.allowSplitHeaders
          ? []
          : candidateGroups.filter((group) => {
              if (group === primaryHeader) {
                return false;
              }

              const groupStart = group.comments[0].loc.start.line;
              const groupEnd = group.comments[group.comments.length - 1].loc.end.line;
              const primaryStart = primaryHeader.comments[0].loc.start.line;
              const primaryEnd = primaryHeader.comments[primaryHeader.comments.length - 1].loc.end.line;

              /**
               * Check if group is adjacent to primary (before or after).
               * The +1 allows for touching lines (no blank line in between).
               */
              const isAdjacentToPrimary =
                groupStart <= primaryEnd + 1 && groupEnd + 1 >= primaryStart;
              const hasAllTags = requiredTagsLower.every((tag) =>
                group.text.toLowerCase().includes(tag),
              );

              return isAdjacentToPrimary && !hasAllTags;
            });

        duplicateGroups.forEach((group) => {
          const firstComment = group.comments[0];
          const removalRange = expandRangeToFullLines(
            [firstComment.range[0], group.comments[group.comments.length - 1].range[1]],
            sourceText,
          );

          context.report({
            loc: firstComment.loc,
            messageId: 'duplicateHeader',
            data: {
              line: firstComment.loc.start.line.toString(),
            },
            fix: (fixer) => fixer.removeRange(removalRange),
          });
        });

        splitHeaderGroups.forEach((group) => {
          const firstComment = group.comments[0];

          context.report({
            loc: firstComment.loc,
            messageId: 'splitHeaderFragment',
            data: {
              tags: options.requiredTags.join(', '),
            },
            fix: null,
          });
        });
      },
    };
  },
});
