import { TSESTree } from '@typescript-eslint/utils';
import { createRule } from '../utils/createRule';
import { minimatch } from 'minimatch';

type MessageIds = 'duplicateHeader' | 'missingHeader' | 'missingRequiredField';

interface Options {
  requireHeader?: boolean;
  filePatterns?: string[];
  requiredFields?: string[];
  allowMultipleBlocks?: boolean;
  excludePatterns?: string[];
}

const defaultOptions: Required<Options> = {
  requireHeader: true,
  filePatterns: ['**/*.ts', '**/*.tsx', '**/*.js', '**/*.jsx'],
  requiredFields: ['@fileoverview'],
  allowMultipleBlocks: false,
  excludePatterns: [
    '**/node_modules/**',
    '**/*.d.ts',
    '**/*.generated.*',
    '**/*.min.*',
  ],
};

export const enforceUniqueCursorHeaders = createRule<[Options], MessageIds>({
  name: 'enforce-unique-cursor-headers',
  meta: {
    type: 'suggestion',
    docs: {
      description:
        'Enforce unique cursor headers and prevent duplicates in files',
      recommended: 'error',
    },
    fixable: 'code',
    schema: [
      {
        type: 'object',
        properties: {
          requireHeader: {
            type: 'boolean',
            default: true,
          },
          filePatterns: {
            type: 'array',
            items: { type: 'string' },
            default: ['**/*.ts', '**/*.tsx', '**/*.js', '**/*.jsx'],
          },
          requiredFields: {
            type: 'array',
            items: { type: 'string' },
            default: ['@fileoverview'],
          },
          allowMultipleBlocks: {
            type: 'boolean',
            default: false,
          },
          excludePatterns: {
            type: 'array',
            items: { type: 'string' },
            default: [
              '**/node_modules/**',
              '**/*.d.ts',
              '**/*.generated.*',
              '**/*.min.*',
            ],
          },
        },
        additionalProperties: false,
      },
    ],
    messages: {
      duplicateHeader:
        'Duplicate cursor header found. Remove the duplicate header block.',
      missingHeader:
        'File is missing a required cursor header. Add a header comment block at the top of the file.',
      missingRequiredField:
        'Cursor header is missing required field: {{field}}. Add the field to the header.',
    },
  },
  defaultOptions: [defaultOptions],
  create(context, [options]) {
    const userOptions = {
      ...defaultOptions,
      ...options,
    };

    const filename = context.getFilename();
    const sourceCode = context.getSourceCode();

    // Check if file should be processed
    if (
      !userOptions.filePatterns.some((pattern) =>
        minimatch(filename, pattern),
      ) ||
      userOptions.excludePatterns?.some((pattern) =>
        minimatch(filename, pattern),
      )
    ) {
      return {};
    }

    // Check if file is auto-generated
    function isAutoGenerated(): boolean {
      const firstComment = sourceCode.getAllComments()[0];
      if (firstComment) {
        const content = firstComment.value.toLowerCase();
        return (
          content.includes('auto-generated') ||
          content.includes('generated') ||
          content.includes('do not edit')
        );
      }
      return false;
    }

    // Check if comment is a cursor header
    function isCursorHeader(comment: TSESTree.Comment): boolean {
      const content = comment.value;
      return userOptions.requiredFields.some((field) =>
        content.includes(field),
      );
    }

    // Get normalized content for comparison
    function getCursorHeaderContent(comment: TSESTree.Comment): string {
      const lines = comment.value
        .split('\n')
        .map((line) => line.trim().replace(/^\*\s*/, ''))
        .filter((line) => line.length > 0);
      return lines.join('\n');
    }

    // Group consecutive single-line comments into logical headers
    function groupCursorHeaders(
      comments: TSESTree.Comment[],
    ): TSESTree.Comment[][] {
      const groups: TSESTree.Comment[][] = [];
      let currentGroup: TSESTree.Comment[] = [];

      for (const comment of comments) {
        if (isCursorHeader(comment)) {
          // If this is a single-line comment and we have a current group of single-line comments
          if (
            comment.type === 'Line' &&
            currentGroup.length > 0 &&
            currentGroup[0].type === 'Line'
          ) {
            // Check if this comment is consecutive (within 1 line)
            const lastComment = currentGroup[currentGroup.length - 1];
            if (comment.loc.start.line - lastComment.loc.end.line <= 1) {
              currentGroup.push(comment);
              continue;
            }
          }

          // Start a new group
          if (currentGroup.length > 0) {
            groups.push(currentGroup);
          }
          currentGroup = [comment];
        }
      }

      if (currentGroup.length > 0) {
        groups.push(currentGroup);
      }

      return groups;
    }

    // Check if two header groups are duplicates
    function areGroupsDuplicate(
      group1: TSESTree.Comment[],
      group2: TSESTree.Comment[],
    ): boolean {
      const content1 = group1.map((c) => getCursorHeaderContent(c)).join('\n');
      const content2 = group2.map((c) => getCursorHeaderContent(c)).join('\n');
      return content1 === content2;
    }

    return {
      Program(node: TSESTree.Program) {
        if (isAutoGenerated()) {
          return;
        }

        const comments = sourceCode.getAllComments();
        const topLevelComments = comments.filter(
          (comment) =>
            comment.loc.start.line <= 10 &&
            !node.body.some(
              (stmt) => stmt.loc.start.line <= comment.loc.start.line,
            ),
        );

        const cursorHeaderGroups = groupCursorHeaders(topLevelComments);

        // Check for duplicates
        const duplicates: TSESTree.Comment[] = [];
        for (let i = 0; i < cursorHeaderGroups.length; i++) {
          for (let j = i + 1; j < cursorHeaderGroups.length; j++) {
            if (
              areGroupsDuplicate(cursorHeaderGroups[i], cursorHeaderGroups[j])
            ) {
              duplicates.push(
                ...cursorHeaderGroups[j].map((comment) => comment),
              );
            }
          }
        }

        // Report duplicates
        duplicates.forEach((duplicate) => {
          context.report({
            loc: {
              start: {
                line: duplicate.loc.start.line,
                column: duplicate.loc.start.column,
              },
              end: {
                line: duplicate.loc.end.line,
                column: duplicate.loc.end.column,
              },
            },
            messageId: 'duplicateHeader',
            fix(fixer) {
              // Remove the duplicate comment block
              const range = duplicate.range;
              const sourceText = sourceCode.getText();

              // Find the start of the line containing this comment
              let startPos = range[0];
              while (startPos > 0 && sourceText[startPos - 1] !== '\n') {
                startPos--;
              }

              // Find the end including any trailing whitespace/newlines
              let endPos = range[1];

              // Skip any trailing whitespace and newlines after the comment
              while (
                endPos < sourceText.length &&
                /\s/.test(sourceText[endPos])
              ) {
                endPos++;
                // Stop after we've consumed one newline and any following whitespace
                if (sourceText[endPos - 1] === '\n') {
                  // Skip any additional whitespace on the next line
                  while (
                    endPos < sourceText.length &&
                    /[ \t]/.test(sourceText[endPos])
                  ) {
                    endPos++;
                  }
                  break;
                }
              }

              return fixer.removeRange([startPos, endPos]);
            },
          });
        });

        // Check for missing headers (only if no duplicates and requireHeader is true)
        if (
          userOptions.requireHeader &&
          cursorHeaderGroups.length === 0 &&
          duplicates.length === 0
        ) {
          const headerTemplate = userOptions.requiredFields
            .map((field) => {
              if (field === '@fileoverview') {
                return ` * ${field} TODO: Add file description`;
              }
              return ` * ${field} TODO: Add ${field.replace('@', '')} information`;
            })
            .join('\n');

          context.report({
            loc: { start: { line: 1, column: 0 }, end: { line: 1, column: 0 } },
            messageId: 'missingHeader',
            fix(fixer) {
              return fixer.insertTextBefore(
                sourceCode.ast,
                `/**\n${headerTemplate}\n */\n\n`,
              );
            },
          });
        }

        // Check for missing required fields in existing headers
        cursorHeaderGroups.forEach((group) => {
          const combinedContent = group
            .map((comment) => comment.value)
            .join('\n');
          userOptions.requiredFields.forEach((field) => {
            if (!combinedContent.includes(field)) {
              context.report({
                loc: {
                  start: {
                    line: group[0].loc.start.line,
                    column: group[0].loc.start.column,
                  },
                  end: {
                    line: group[group.length - 1].loc.end.line,
                    column: group[group.length - 1].loc.end.column,
                  },
                },
                messageId: 'missingRequiredField',
                data: { field },
              });
            }
          });
        });

        // Check for multiple non-duplicate headers when not allowed
        if (
          !userOptions.allowMultipleBlocks &&
          cursorHeaderGroups.length > 1 &&
          duplicates.length === 0
        ) {
          cursorHeaderGroups.slice(1).forEach((group) => {
            group.forEach((header) => {
              context.report({
                loc: {
                  start: {
                    line: header.loc.start.line,
                    column: header.loc.start.column,
                  },
                  end: {
                    line: header.loc.end.line,
                    column: header.loc.end.column,
                  },
                },
                messageId: 'duplicateHeader',
                fix(fixer) {
                  // For now, just remove additional headers
                  const range = header.range;
                  const sourceText = sourceCode.getText();

                  // Find the start of the line containing this comment
                  let startPos = range[0];
                  while (startPos > 0 && sourceText[startPos - 1] !== '\n') {
                    startPos--;
                  }

                  // Find the end including any trailing whitespace/newlines
                  let endPos = range[1];

                  // Skip any trailing whitespace and newlines after the comment
                  while (
                    endPos < sourceText.length &&
                    /\s/.test(sourceText[endPos])
                  ) {
                    endPos++;
                    // Stop after we've consumed one newline and any following whitespace
                    if (sourceText[endPos - 1] === '\n') {
                      // Skip any additional whitespace on the next line
                      while (
                        endPos < sourceText.length &&
                        /[ \t]/.test(sourceText[endPos])
                      ) {
                        endPos++;
                      }
                      break;
                    }
                  }

                  return fixer.removeRange([startPos, endPos]);
                },
              });
            });
          });
        }
      },
    };
  },
});
